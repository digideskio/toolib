<?php

//! Helper object for @b ONE db connection with MySQL (5+)
/**
    An easy way to organize prepared staments and execute them
    with centralized error handling. It also supports optional
    delayed preparation until a statement is run for the first
    time.
  */
class dbconn
{
    //! Connection handler
	static private $dbconn;

    //! The array with all statemenets
    static private $stmts;

    //! Set error handler function
    static private $error_handler_func;
	
	//! delayed preparation
	static private $delayed_preparation;
	
    //! Initialize db connection
    /**
        @param $server The dns or ip of the server to connect at.
        @param $user The user to use for authentication.
        @param $pass The password that will be used for authentication.
        @param $schema The schema to use as default for this connection.
        @param $error_handler A callback function to call when an error is raised
            by any of the functions of dbconn. The function will get one parameter
            with the detailed message.
        @param $delayed_preparation A flag if delayed preparation should be used to
            improve performance.
    */
	static public function init($server, $user, $pass, $schema, $error_handler = false, $delayed_preparation = true)
	{
        // Save error handler function
        dbconn::$error_handler_func = $error_handler;
        dbconn::$delayed_preparation = $delayed_preparation;

		// Database connection (server, user, password, schema)
		if (!(dbconn::$dbconn = new mysqli($server, $user, $pass, $schema)))
		{
		    dbconn::raise_error('Cannot create connection with database.');
		    return false;
		}

        // Create the array of statemenets
        dbconn::$stmts = array();
        return true;
	}
	
	//! Change the default character set of the conncetion
	static public function set_charset($charset)
	{
	   if (!dbconn::$dbconn)
	   {
	       dbconn::raise_error('Cannot change the character set as there is no connction yet!');
	       return false;
	   }
	   
	   if (!dbconn::$dbconn->set_charset($charset))
	   {
	       dbconn::raise_error('Cannot change the character set. ' . dbconn::$dbconn->error);
	       return false;
	   }
	   return true;
	}
	
	//! Get the connection link
	static public function get_link()
	{
	   if (!dbconn::$dbconn)
	   {
	       dbconn::raise_error('dbconn::get_link() was executed before establishing a connection');
	       return false;
	   }
	   
	   return dbconn::$dbconn;
	}
	
	
	//! Get the id generated by the last insert command.
	/** 
	   Get last id that a command generated with an 
	   INSERT command on a column with auto_increment option
	*/
	static public function last_insert_id()
	{  return dbconn::$dbconn->insert_id;    }

    //! It does the actual statement prepartion (used for delayed prepartion)
    static private function assure_preparation($key)
    {
    	// Check if it must be prepared now
       	if (!isset(dbconn::$stmts[$key]['handler']))
       	{
       	    // Prepare statement
           if (!($stmt = dbconn::$dbconn->prepare(dbconn::$stmts[$key]['query'])))
      	    {   dbconn::raise_error("Cannot prepare statement '" . $key . "'.\n" . dbconn::$dbconn->error);
      	        return false;
      	    }
      	    dbconn::$stmts[$key]['handler'] = $stmt;
       	}
       	return true;
    }
    
    //! Prepare a statment and save it internally
    /**
        @param $key The unique name of the prepared statement, this will be used to execute
            the statement too.
        @param $query The query of the statement.
     */
    static public function prepare($key, $query)
    {
        // Check if the key is free
        if (isset(dbconn::$stmts[$key]))
        {   dbconn::raise_error('There is already a statement prepared with this key "' . $key . '".');
            return false;
        }
        
        // Create statement entry
        dbconn::$stmts[$key] = array('query' => $query);
        
        // Delayed preparation check
        if (!dbconn::$delayed_preparation)
            return dbconn::assure_preparation($key);
        
	    return dbconn::$stmts[$key];
	}
	
    //! Prepare multiple statements with one call.
    /**
        Statements are given using an array(key => statement, key => statement)..
    */
    static public function multi_prepare($statements)
    {
        foreach($statements as $key => $query)
        {   dbconn::prepare($key, $query);   }
    }

    //! Raise an error
    static private function raise_error($msg)
    {
        if (dbconn::$error_handler_func)
        {
            call_user_func(dbconn::$error_handler_func, $msg);
            return;
        }

        // Else back to default error action
        echo $msg;
    }

    //! Execute a direct query in database and return result set
    static public function query($query)
    {   // Query db connection
        if (!$res = dbconn::$dbconn->query($query))
            dbconn::raise_error('dbconn::query(' . $query . ') error on executing query.' . dbconn::$dbconn->error);

        return $res;
    }
    
    //! Execute a direct query in database and get all results immediatly
    static public function query_fetch_all($query)
    {   if (!$res = dbconn::query($query))
            return false;
        
        $results = array();
        while($row = $res->fetch_array())
            $results[] = $row;
        $res->free_result();
        return $results;
    }
    
    //! A macro for binding and executing a statement
    /**
        It must be used in the form <b> dbconn::execute($stmt_key, $bind_desc_string, $bind1, .. ,$bindN) </b> \n
        If there are no parametes you can use it stmt_bind_and_execute($stmt_key)
     @return It will return false on fail or the statement handler to fetch data.
    */
    static public function execute()
    {
        if (func_num_args() < 1)
        {   dbconn::raise_error('dbconn::stmt_execute() requires at least 1 arguments. See the manual for more info.');
            return false;
        }
       	$key = func_get_arg(0);
       	
       	// Check if statement exist
       	if (!isset(dbconn::$stmts[$key]))
       	{
       	    dbconn::raise_error('dbconn::execute(' . $key . ') The supplied statement must first be prepared using dbconn::prepare().');
       	    return false;
       	}
       	
       	// Assure preparation
       	if (!dbconn::assure_preparation($key))
       	    return false;

        // Bind parameters if it is needed
        if (func_num_args() >=3)
        {
            $args = array_slice(func_get_args(), 1);
	        call_user_func_array(array(dbconn::$stmts[$key]['handler'], 'bind_param'), $args);
	    }
	    
	    // Execute statement
	    if (!dbconn::$stmts[$key]['handler']->execute())
	    {   dbconn::raise_error('Cannot execute the prepared statement "' . $key . '".' . dbconn::$stmts[$key]['handler']->error);
	        return false;
	    }
	    return dbconn::$stmts[$key]['handler'];
    }

    //! A macro for executing a statement and getting all results
    /**
      @note This is function is slow.
        To use this function check the documentation of dbconn::execute().
      @return It will return false on fail or an array with all results.
     */
    static public function execute_fetch_all()
    {   // Execute the statement
        $exec_params = func_get_args();
        if (!($stmt = call_user_func_array(array('dbconn', 'execute'), $exec_params)))
            return false;

        if ($stmt->field_count <= 0)
            return true;        // This statement has no result
        
        // Get the name of fields
        $result = $stmt->result_metadata();
        $fields = $result->fetch_fields();
        $result->close();

        // Create an anonymous function that will query fetch all data
        $fcode = '$stmt->bind_result($res0';
        for($i = 1; $i < $stmt->field_count; $i++)
            $fcode .= ', $res' . $i;
        $fcode .= '); ';
        $fcode .= '$res = array(); while($stmt->fetch()){ $row = array(); $row[0] = $res0; $row[\''. $fields[0]->name .'\'] = $res0; ';
        for($i = 1; $i < $stmt->field_count; $i++)
        {
            $fcode .= '$row['. $i .'] = $res' . $i .';';
            $fcode .= '$row[\''. $fields[$i]->name .'\'] = $res' . $i .';';
        }
        $fcode .=' $res[] = $row; }';
        $fcode .=' return $res;';
        
        // Execute anonynoums function
        $fetch = create_function('$stmt', $fcode);
        return $fetch($stmt);
    }
};

?>
