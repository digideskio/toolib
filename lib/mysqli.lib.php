<?php

//! Helper object for @b ONE db connection with MySQL (5+)
/** 
    An easy way to organize prepared staments and execute them
    with centralized error handling. It also supports optional
    delayed preparation until a statement is run for the first
    time.
  */
class dbconn
{
    //! Connection handler
	static private $dbconn;

    //! The array with all statemenets
    static private $stmts;

    //! Set error handler function
    static private $error_handler_func;
	
	//! delayed preparation
	static private $delayed_preparation;
	
	//! Packet size when sending binary packets
	static public $binary_packet_size = 32768;
	
    //! Initialize db connection
    /** 
        @param $server The dns or ip of the server to connect at.
        @param $user The user to use for authentication.
        @param $pass The password that will be used for authentication.
        @param $schema The schema to use as default for this connection.
        @param $error_handler A callback function to call when an error is raised
            by any of the functions of dbconn. The function will get one parameter
            with the detailed message.
        @param $delayed_preparation A flag if delayed preparation should be used to
            improve performance.
    */
	static public function init($server, $user, $pass, $schema, $error_handler = false, $delayed_preparation = true)
	{
        // Save error handler function
        dbconn::$error_handler_func = $error_handler;
        dbconn::$delayed_preparation = $delayed_preparation;

		// Database connection (server, user, password, schema)
		if (!(dbconn::$dbconn = new mysqli($server, $user, $pass, $schema)))
		{
		    dbconn::raise_error('Cannot create connection with database.');
		    return false;
		}

        // Create the array of statemenets
        dbconn::$stmts = array();
        return true;
	}
	
	//! Change the default character set of the conncetion
	static public function set_charset($charset)
	{
	   if (!dbconn::$dbconn)
	   {
	       dbconn::raise_error('Cannot change the character set as there is no connction yet!');
	       return false;
	   }
	   
	   if (!dbconn::$dbconn->set_charset($charset))
	   {
	       dbconn::raise_error('Cannot change the character set. ' . dbconn::$dbconn->error);
	       return false;
	   }
	   return true;
	}
	
	//! Get the connection link
	static public function get_link()
	{
	   if (!dbconn::$dbconn)
	   {
	       dbconn::raise_error('dbconn::get_link() was executed before establishing a connection');
	       return false;
	   }
	   
	   return dbconn::$dbconn;
	}
	
	
	//! Get the id generated by the last insert command.
	/** 
	   Get last id that a command generated with an 
	   INSERT command on a column with auto_increment option
	*/
	static public function last_insert_id()
	{  return dbconn::$dbconn->insert_id;    }

    //! It does the actual statement prepartion (used for delayed prepartion)
    static private function assure_preparation($key)
    {
    	// Check if it must be prepared now
       	if (!isset(dbconn::$stmts[$key]['handler']))
       	{
       	    // Prepare statement
           if (!($stmt = dbconn::$dbconn->prepare(dbconn::$stmts[$key]['query'])))
      	    {   dbconn::raise_error("Cannot prepare statement '" . $key . "'.\n" . dbconn::$dbconn->error);
      	        return false;
      	    }
      	    dbconn::$stmts[$key]['handler'] = $stmt;
       	}
       	return true;
    }
    
    //! Prepare a statment and save it internally
    /** 
        @param $key The unique name of the prepared statement, this will be used to execute
            the statement too.
        @param $query The query of the statement.
     */
    static public function prepare($key, $query)
    {
        // Check if the key is free
        if (isset(dbconn::$stmts[$key]))
        {   dbconn::raise_error('There is already a statement prepared with this key "' . $key . '".');
            return false;
        }
        
        // Create statement entry
        dbconn::$stmts[$key] = array('query' => $query);
        
        // Delayed preparation check
        if (!dbconn::$delayed_preparation)
            return dbconn::assure_preparation($key);
        
	    return dbconn::$stmts[$key];
	}
	
    //! Prepare multiple statements with one call.
    /** 
        Statements are given using an array(key => statement, key => statement)..
    */
    static public function multi_prepare($statements)
    {
        foreach($statements as $key => $query)
        {   dbconn::prepare($key, $query);   }
    }

    //! Raise an error
    static private function raise_error($msg)
    {
        if (dbconn::$error_handler_func)
        {
            call_user_func(dbconn::$error_handler_func, $msg);
            return;
        }

        // Else back to default error action
        echo $msg;
    }

    //! Execute a direct query in database and return result set
    static public function query($query)
    {   // Query db connection
        if (!$res = dbconn::$dbconn->query($query))
            dbconn::raise_error('dbconn::query(' . $query . ') error on executing query.' . dbconn::$dbconn->error);

        return $res;
    }
    
    //! Execute a direct query in database and get all results immediatly
    static public function query_fetch_all($query)
    {   if (!$res = dbconn::query($query))
            return false;
        
        $results = array();
        while($row = $res->fetch_array())
            $results[] = $row;
        $res->free_result();
        return $results;
    }
    
    //! A macro for binding and executing a statement
    /** 
        It must be used in the form <b> dbconn::execute($stmt_key, $bind_desc_string, $bind1, .. ,$bindN) </b> \n
        If there are no parametes you can use it stmt_bind_and_execute($stmt_key)
     @return It will return false on fail or the statement handler to fetch data.
     @note If you are executing statement that contains a binary parameter (marked with "b") the data are
     	send in chunks with maximum size $binary_packet_size . Modifiyng this public variable may change the
     	significantly the performance of this query.
    */
    static public function execute()
    {	
        if (func_num_args() < 1)
        {   dbconn::raise_error('dbconn::stmt_execute() requires at least 1 arguments. See the manual for more info.');
            return false;
        }
       	$key = func_get_arg(0);
       	
       	// Check if statement exist
       	if (!isset(dbconn::$stmts[$key]))
       	{
       	    dbconn::raise_error('dbconn::execute(' . $key . ') The supplied statement must first be prepared using dbconn::prepare().');
       	    return false;
       	}
       	
       	// Assure preparation
       	if (!dbconn::assure_preparation($key))
       	    return false;

        // Bind parameters if it is needed
        if (func_num_args() >=3)
        {
            $args = array_slice(func_get_args(), 1);
	        call_user_func_array(array(dbconn::$stmts[$key]['handler'], 'bind_param'), $args);

        	// Send blob data
        	$types = str_split($args[0], 1);
        	foreach($types as $pos => $type)
        		if ($type == 'b')
        		{	foreach(str_split($args[$pos+1], self::$binary_packet_size) as $data )
        				call_user_func(array(dbconn::$stmts[$key]['handler'], 'send_long_data'), $pos, $data);
        		}
        }	    
	    
	    // Execute statement
	    if (!dbconn::$stmts[$key]['handler']->execute())
	    {   dbconn::raise_error('Cannot execute the prepared statement "' . $key . '". ' . dbconn::$stmts[$key]['handler']->error);
	        return false;
	    }
	    return dbconn::$stmts[$key]['handler'];
    }

    //! A macro for executing a statement and getting all results
    /** 
      @note This function is not slower than getting manually one-by-one rows and loading in memory.      
        To use this function check the documentation of dbconn::execute().
      @return It will return false on fail or an array with all results.
     */
    static public  function & execute_fetch_all()
    {   // Execute the statement
        $exec_params = func_get_args();
		
        if (!($stmt = call_user_func_array(array('dbconn', 'execute'), $exec_params)))
            return false;

        if ($stmt->field_count <= 0)
            return true;        // This statement has no result
        
        // Get the name of fields
        if (($result = $stmt->result_metadata()) === NULL)
        	return array();	// This query has no result set
        $fields = $result->fetch_fields();
        $result->close();

		// Bind results on each cell of bnd_res array
		$bnd_res = array_fill(0, $stmt->field_count, NULL);
		$bnd_param = array();
		foreach($bnd_res as $k => &$bnd)
			$bnd_param[] = & $bnd;
		unset($bnd);
		$stmt->store_result();
		call_user_func_array(array($stmt, 'bind_result'), $bnd_param);

		// Get results one by one
		$array_result = array();
		while($stmt->fetch())
		{	$row = array();
			for($i = 0; $i < $stmt->field_count; $i++)
			{
				$row[$i] = $bnd_res[$i];
				$row[$fields[$i]->name] = & $row[$i];
			}
			$array_result[] = $row;
		}
		$stmt->free_result();
		
		return $array_result;
    }
};

?>
