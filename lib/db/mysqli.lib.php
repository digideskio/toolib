<?php
require_once(dirname(__FILE__) . '/../events.lib.php');

//! Helper object for @b ONE db connection with MySQL (5+)
/**
 * An easy way to organize prepared staments and execute them
 * with centralized error handling. It also supports optional
 * delayed preparation until a statement is run for the first
 * time.
 */
class dbconn
{
    //! Connection handler
	static private $dbconn;

    //! The array with all statemenets
    static private $stmts;

    //! Set error handler function
    static private $error_handler_func;
	
	//! delayed preparation
	static private $delayed_preparation;
	
	//! Packet size when sending binary packets
	static public $binary_packet_size = 32768;
	
	//! Events advertised by dbconn
	/**
	 * Events are exported through an EventsDispatcher object. The following
	 * events are exported:
	 * 	- @b error : Executed on any error that has been emitted from dbconn.
	 *  - @b init: Executed after dbconn has been initialized.
	 *  - @b query: Perform a direct query on the connection.
	 *  - @b stmt.declared: Request preparation of a statement. 
	 *  - @b stmt.prepared: A requested statement was prepared.
	 *  - @b stmt.executed: A prepared statement was executed.
	 * .
	 */
	static public $events = NULL;
	
    //! Initialize db connection
    /** 
	 * @param $server The dns or ip of the server to connect at.
	 * @param $user The user to use for authentication.
	 * @param $pass The password that will be used for authentication.
	 * @param $schema The schema to use as default for this connection.
	 * @param $error_handler A callback function to call when an error is raised
	 * 		by any of the functions of dbconn. The function will get one parameter
	 * 		with the detailed message.
	 * 	@param $delayed_preparation A flag if delayed preparation should be used to
	 * 		improve performance.
	 */
	static public function init($server, $user, $pass, $schema, $delayed_preparation = true)
	{
        // Create events dispatcher if it does not exist
        if (self::$events === NULL)
	        self::$events = new EventDispatcher(array(
	        	'error',
	        	'init',
	        	'query',
	        	'stmt.declared',
	        	'stmt.prepared',
	        	'stmt.executed',
	        ));
        self::$delayed_preparation = $delayed_preparation;

		// Database connection (server, user, password, schema)
		if (!(self::$dbconn = new mysqli($server, $user, $pass, $schema)))
		{
		    self::raise_error('Cannot create connection with database.');
		    return false;
		}

        // Create the array of statemenets
        self::$stmts = array();
        self::$events->notify('init');
        return true;
	}
	
	//! Change the default character set of the conncetion
	static public function set_charset($charset)
	{
	   if (!self::$dbconn)
	   {
	       self::raise_error('Cannot change the character set as there is no connction yet!');
	       return false;
	   }
	   
	   if (!self::$dbconn->set_charset($charset))
	   {
	       self::raise_error('Cannot change the character set. ' . self::$dbconn->error);
	       return false;
	   }
	   return true;
	}
	
	//! Get the connection link
	static public function get_link()
	{
	   if (!self::$dbconn)
	   {
	       self::raise_error('dbconn::get_link() was executed before establishing a connection');
	       return false;
	   }
	   
	   return self::$dbconn;
	}
	
	//! Escape a string for mysql usage
	static public function escape_string($str)
	{	if (!self::$dbconn)
		{
       		self::raise_error('dbconn::get_link() was executed before establishing a connection');
       		return false;
   		}
   		return self::$dbconn->real_escape_string($str);
	}
	//! Get the id generated by the last insert command.
	/** 
     * Get last id that a command generated with an 
     * INSERT command on a column with auto_increment option
	 */
	static public function last_insert_id()
	{  return self::$dbconn->insert_id;    }

    //! It does the actual statement prepartion (used for delayed prepartion)
    static private function assure_preparation($key)
    {
    	// Check if it must be prepared now
       	if (!isset(self::$stmts[$key]['handler']))
       	{
       	    // Prepare statement
           if (!($stmt = self::$dbconn->prepare(self::$stmts[$key]['query'])))
      	    {   self::raise_error("Cannot prepare statement '" . $key . "'. " . self::$dbconn->error);
      	        return false;
      	    }
      	    self::$stmts[$key]['handler'] = $stmt;
      	    
      	    self::$events->notify('stmt.prepared', array('key' => $key));
       	}
       	return true;
    }
    
    //! Check if a statement key is used
    /**
     * Check if this key is already used in prepared statements
     * @param $key The key to be checked 
     * @return @i bool @b TRUE if it is already used or @b FALSE if it is not used.
     */
    static public function is_key_used($key)
    {
    	return isset(self::$stmts[$key]);
    }
    
    //! Prepare a statment and save it internally
    /**
     *  
     * @param $key The unique name of the prepared statement, this will be used to execute
     * 	the statement too.
     * @param $query The query of the statement.
     */
    static public function prepare($key, $query)
    {
        // Check if the key is free
        if (isset(self::$stmts[$key]))
        {   self::raise_error('There is already a statement prepared with this key "' . $key . '".');
            return false;
        }
        
        // Create statement entry
        self::$stmts[$key] = array('query' => $query);
        
        // Delayed preparation check
        if (!self::$delayed_preparation)
            return self::assure_preparation($key);
        
        self::$events->notify('stmt.declared', array('key' => $key, 'query' => $query));
        
	    return self::$stmts[$key];
	}
	
    //! Prepare multiple statements with one call.
    /**
     * Statements are given using an array(key => statement, key => statement)..
     */
    static public function multi_prepare($statements)
    {
        foreach($statements as $key => $query)
        {   self::prepare($key, $query);   }
    }

    //! Raise an error
    static private function raise_error($msg)
    {	// Notify about the error
        self::$events->notify('error', array('message' => $msg));

        // Else back to default error action
        echo $msg;
    }

    //! Execute a direct query in database and return result set
    static public function query($query)
    {       
        // Query db connection
        if (!$res = self::$dbconn->query($query))
            self::raise_error('dbconn::query(' . $query . ') error on executing query.' . self::$dbconn->error);

        // Command executed
        self::$events->notify('query', array('query' => $query));

        return $res;
    }
    
    //! Execute a direct query in database and get all results immediatly
    static public function query_fetch_all($query)
    {   if (!$res = self::query($query))
            return false;
        
        $results = array();
        while($row = $res->fetch_array())
            $results[] = $row;
        $res->free_result();
        
        return $results;
    }
    
	//! A macro for binding and executing a statement
    /**
     * @param $key The key of the statement that was used to prepare.
     * @param $param_data An associative array with all data that will be passed as parameters to prepared statement.
     * 	Key of array must be the order of parameter in the statement or the name of parameter if it was declared
     *  using names in the statement.
     * @param $param_types An associative array with type of data of previous array. If an entry is missing
     * 	it defaults to string type.
     * @return It will return false on fail or the statement handler to fetch data.
     * @note If you are executing statement that contains a binary parameter (marked with "b") the data are
     *	send in chunks with maximum size $binary_packet_size . Modifiyng this public variable may change the
     *	significantly the performance of this query.
     */
    static public function execute($key, $param_data = NULL, $param_types = NULL)
    {	
       	// Check if statement exist
       	if (!isset(self::$stmts[$key]))
       	{
       	    self::raise_error('dbconn::execute("' . $key . '") The supplied statement must first be prepared using dbconn::prepare().');
       	    return false;
       	}
       	
       	// Assure preparation
       	if (!self::assure_preparation($key))
       	    return false;

        // Bind parameters if it is needed
        if (($param_data !== NULL) && (count($param_data) !== 0))
        {	
			$params = array('');
        	foreach($param_data as $index => $data)
        	{	// Normalize type
        		$params[0] .= (isset($param_types[$index]))?$param_types[$index]:'s';        		
        		$params[] = & $param_data[$index];
        	}
        	// Bind parameters
			call_user_func_array(array(self::$stmts[$key]['handler'], 'bind_param'), $params);
        	
        	// Send blob data
        	if ($param_types !== NULL)
        	{
	        	foreach($param_types as $pos => $type)
	        		if ($type == 'b')
	        		{	foreach(str_split($param_data[$pos], self::$binary_packet_size) as $data )
	        				self::$stmts[$key]['handler']->send_long_data($pos, $data);
	        		}
        	}
        }

	    // Execute statement
	    if (!self::$stmts[$key]['handler']->execute())
	    {   self::raise_error('Cannot execute the prepared statement "' . $key . '". ' . self::$stmts[$key]['handler']->error);
	        return false;
	    }
	    
	    self::$events->notify('stmt.executed', array_merge(array($key), (isset($args)?$args:array())));
	    
	    return self::$stmts[$key]['handler'];
    }

    //! A macro for executing a statement and getting all results in one query
    /** 
     * @note This function is not slower than getting manually one-by-one rows and loading in memory.      
     * 	To use this function check the documentation of dbconn::execute().
     * @return It will return false on fail or an array with all results.
     */
    static public function & execute_fetch_all($key, $param_data = NULL, $param_types = NULL)
    {   
		if (! ($stmt = self::execute($key, $param_data, $param_types)))
        {	$res = false;
            return $res;
        }

        if ($stmt->field_count <= 0)
        {	
        	$res = array();
            return $res;        // This statement has no result
        }
		
        // Get the name of fields
        if (($result = $stmt->result_metadata()) === NULL)
        	return array();	// This query has no result set
        $fields = $result->fetch_fields();
        $result->close();

		// Bind results on each cell of bnd_res array
		$bnd_res = array_fill(0, $stmt->field_count, NULL);
		$bnd_param = array();
		foreach($bnd_res as $k => &$bnd)
			$bnd_param[] = & $bnd;
		unset($bnd);
		$stmt->store_result();
		call_user_func_array(array($stmt, 'bind_result'), $bnd_param);

		// Get results one by one
		$array_result = array();
		while($stmt->fetch())
		{	$row = array();
			for($i = 0; $i < $stmt->field_count; $i++)
			{
				$row[$i] = $bnd_res[$i];
				$row[$fields[$i]->name] = & $row[$i];
			}
			$array_result[] = $row;
		}
		$stmt->free_result();
		
		return $array_result;
    }
};

?>
