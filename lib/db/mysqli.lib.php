<?php
require_once(dirname(__FILE__) . '/../events.lib.php');

//! Helper object for @b ONE db connection with MySQL (5+)
/**
 * An easy way to organize prepared staments and execute them
 * with centralized error handling. It also supports optional
 * delayed preparation until a statement is run for the first
 * time.
 */
class dbconn
{
    //! Connection handler
	static private $dbconn;

    //! The array with all statemenets
    static private $stmts;

    //! Set error handler function
    static private $error_handler_func;
	
	//! delayed preparation
	static private $delayed_preparation;
	
	//! Packet size when sending binary packets
	static public $binary_packet_size = 32768;
	
	//! Events advertised by dbconn
	/**
	 * Events are exported through an EventsDispatcher object. The following
	 * events are exported:
	 * 	- @b error : Executed in case of any error produced by 
	 *  - @b init : Executed after dbconn has been initialized
	 *  - @b req-prepare: Request preparation of a statement. 
	 *  - @b prepared: A requested statement was prepared.
	 *  - @b executed: A prepared statement was executed.
	 *  - @b query: Perform a direct query on the connection
	 * .
	 */
	static public $events = NULL;
	
    //! Initialize db connection
    /** 
	 * @param $server The dns or ip of the server to connect at.
	 * @param $user The user to use for authentication.
	 * @param $pass The password that will be used for authentication.
	 * @param $schema The schema to use as default for this connection.
	 * @param $error_handler A callback function to call when an error is raised
	 * 		by any of the functions of dbconn. The function will get one parameter
	 * 		with the detailed message.
	 * 	@param $delayed_preparation A flag if delayed preparation should be used to
	 * 		improve performance.
	 */
	static public function init($server, $user, $pass, $schema, $delayed_preparation = true)
	{
        // Create events dispatcher if it does not exist
        if (self::$events === NULL)
	        self::$events = new EventDispatcher(array(
	        	'error',
	        	'init',
	        	'req-prepare',
	        	'prepared',
	        	'executed',
	        	'query'
	        ));
        self::$delayed_preparation = $delayed_preparation;

		// Database connection (server, user, password, schema)
		if (!(self::$dbconn = new mysqli($server, $user, $pass, $schema)))
		{
		    self::raise_error('Cannot create connection with database.');
		    return false;
		}

        // Create the array of statemenets
        self::$stmts = array();
        self::$events->notify('init');
        return true;
	}
	
	//! Change the default character set of the conncetion
	static public function set_charset($charset)
	{
	   if (!self::$dbconn)
	   {
	       self::raise_error('Cannot change the character set as there is no connction yet!');
	       return false;
	   }
	   
	   if (!self::$dbconn->set_charset($charset))
	   {
	       self::raise_error('Cannot change the character set. ' . self::$dbconn->error);
	       return false;
	   }
	   return true;
	}
	
	//! Get the connection link
	static public function get_link()
	{
	   if (!self::$dbconn)
	   {
	       self::raise_error('dbconn::get_link() was executed before establishing a connection');
	       return false;
	   }
	   
	   return self::$dbconn;
	}
	
	//! Escape a string for mysql usage
	static public function escape_string($str)
	{	if (!self::$dbconn)
		{
       		self::raise_error('dbconn::get_link() was executed before establishing a connection');
       		return false;
   		}
   		return self::$dbconn->real_escape_string($str);
	}
	//! Get the id generated by the last insert command.
	/** 
     * Get last id that a command generated with an 
     * INSERT command on a column with auto_increment option
	 */
	static public function last_insert_id()
	{  return self::$dbconn->insert_id;    }

    //! It does the actual statement prepartion (used for delayed prepartion)
    static private function assure_preparation($key)
    {
    	// Check if it must be prepared now
       	if (!isset(self::$stmts[$key]['handler']))
       	{
       	    // Prepare statement
           if (!($stmt = self::$dbconn->prepare(self::$stmts[$key]['query'])))
      	    {   self::raise_error("Cannot prepare statement '" . $key . "'. " . self::$dbconn->error);
      	        return false;
      	    }
      	    self::$stmts[$key]['handler'] = $stmt;
      	    
      	    self::$events->notify('prepared', $key);
       	}
       	return true;
    }
    
    //! Check if a statement key is used
    /**
     * Check if this key is already used in prepared statements
     * @param $key The key to be checked 
     * @return @i bool @b TRUE if it is already used or @b FALSE if it is not used.
     */
    static public function is_key_used($key)
    {
    	return isset(self::$stmts[$key]);
    }
    
    //! Prepare a statment and save it internally
    /**
     *  
     * @param $key The unique name of the prepared statement, this will be used to execute
     * 	the statement too.
     * @param $query The query of the statement.
     */
    static public function prepare($key, $query)
    {
        // Check if the key is free
        if (isset(self::$stmts[$key]))
        {   self::raise_error('There is already a statement prepared with this key "' . $key . '".');
            return false;
        }
        
        // Create statement entry
        self::$stmts[$key] = array('query' => $query);
        
        // Delayed preparation check
        if (!self::$delayed_preparation)
            return self::assure_preparation($key);
        
        self::$events->notify('req-prepare', array('key' => $key, 'query' => $query));
        
	    return self::$stmts[$key];
	}
	
    //! Prepare multiple statements with one call.
    /**
     * Statements are given using an array(key => statement, key => statement)..
     */
    static public function multi_prepare($statements)
    {
        foreach($statements as $key => $query)
        {   self::prepare($key, $query);   }
    }

    //! Raise an error
    static private function raise_error($msg)
    {	self::$events->notify('error', $msg);

        // Else back to default error action
        echo $msg;
    }

    //! Execute a direct query in database and return result set
    static public function query($query)
    {   // Query db connection
        if (!$res = self::$dbconn->query($query))
            self::raise_error('dbconn::query(' . $query . ') error on executing query.' . self::$dbconn->error);
		
        self::$events->notify('query', $query);
        
        return $res;
    }
    
    //! Execute a direct query in database and get all results immediatly
    static public function query_fetch_all($query)
    {   if (!$res = self::query($query))
            return false;
        
        $results = array();
        while($row = $res->fetch_array())
            $results[] = $row;
        $res->free_result();
        
        return $results;
    }
    
    //! A macro for binding and executing a statement
    /**
     * 
     * It must be used in the form <b> dbconn::execute($stmt_key, $bind_desc_string, $bind1, .. ,$bindN) </b> \n
     * If there are no parametes you can use it stmt_bind_and_execute($stmt_key)
     * @return It will return false on fail or the statement handler to fetch data.
     * @note If you are executing statement that contains a binary parameter (marked with "b") the data are
     *	send in chunks with maximum size $binary_packet_size . Modifiyng this public variable may change the
     *	significantly the performance of this query.
     */
    static public function execute()
    {	
        if (func_num_args() < 1)
        {   self::raise_error('dbconn::stmt_execute() requires at least 1 arguments. See the manual for more info.');
            return false;
        }
       	$key = func_get_arg(0);
       	
       	// Check if statement exist
       	if (!isset(self::$stmts[$key]))
       	{
       	    self::raise_error('dbconn::execute("' . $key . '") The supplied statement must first be prepared using dbconn::prepare().');
       	    return false;
       	}
       	
       	// Assure preparation
       	if (!self::assure_preparation($key))
       	    return false;

        // Bind parameters if it is needed
        if (func_num_args() >=3)
        {
            $args = array_slice(func_get_args(), 1);
	        call_user_func_array(array(self::$stmts[$key]['handler'], 'bind_param'), $args);

        	// Send blob data
        	$types = str_split($args[0], 1);
        	foreach($types as $pos => $type)
        		if ($type == 'b')
        		{	foreach(str_split($args[$pos+1], self::$binary_packet_size) as $data )
        				call_user_func(array(self::$stmts[$key]['handler'], 'send_long_data'), $pos, $data);
        		}
        }	    
	    
	    // Execute statement
	    if (!self::$stmts[$key]['handler']->execute())
	    {   self::raise_error('Cannot execute the prepared statement "' . $key . '". ' . self::$stmts[$key]['handler']->error);
	        return false;
	    }
	    
	    self::$events->notify('executed', array_merge(array($key), (isset($args)?$args:array())));
	    
	    return self::$stmts[$key]['handler'];
    }

    //! A macro for executing a statement and getting all results
    /** 
     * @note This function is not slower than getting manually one-by-one rows and loading in memory.      
     * 	To use this function check the documentation of dbconn::execute().
     * @return It will return false on fail or an array with all results.
     */
    static public  function & execute_fetch_all()
    {   // Execute the statement
        $exec_params = func_get_args();
		
        if (!($stmt = call_user_func_array(array('dbconn', 'execute'), $exec_params)))
        {	$res = false;
            return $res;
        }

        if ($stmt->field_count <= 0)
        {	$res = array();
            return $res;        // This statement has no result
        }
        
        // Get the name of fields
        if (($result = $stmt->result_metadata()) === NULL)
        	return array();	// This query has no result set
        $fields = $result->fetch_fields();
        $result->close();

		// Bind results on each cell of bnd_res array
		$bnd_res = array_fill(0, $stmt->field_count, NULL);
		$bnd_param = array();
		foreach($bnd_res as $k => &$bnd)
			$bnd_param[] = & $bnd;
		unset($bnd);
		$stmt->store_result();
		call_user_func_array(array($stmt, 'bind_result'), $bnd_param);

		// Get results one by one
		$array_result = array();
		while($stmt->fetch())
		{	$row = array();
			for($i = 0; $i < $stmt->field_count; $i++)
			{
				$row[$i] = $bnd_res[$i];
				$row[$fields[$i]->name] = & $row[$i];
			}
			$array_result[] = $row;
		}
		$stmt->free_result();
		
		return $array_result;
    }
};

?>
